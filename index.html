<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keyboard Layout Optimizer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      text-align: center;
    }
    #canvas-container {
      position: relative;
      display: inline-block;
    }
    canvas {
      border: 1px solid #ccc;
    }
    #label-input-container {
      display: none;
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 10px;
      z-index: 10;
    }
    #controls {
      margin-top: 20px;
    }
    #optimization {
      margin-top: 20px;
    }
    #results {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1>Keyboard Layout Optimizer</h1>
  <div id="canvas-container">
    <canvas id="keyboard-canvas"></canvas>
    <div id="label-input-container">
      <input type="text" id="label-input" placeholder="Enter key label">
      <label>
        <span>Color:</span>
        <input type="color" id="color-picker" value="#ff0000">
      </label>
      <button id="add-label-button">Add</button>
    </div>
  </div>
  <div id="controls">
    <button id="upload-template">Upload Keyboard Template</button>
    <button id="save-layout">Save Layout</button>
    <button id="load-layout">Load Layout</button>
    <button id="save-image">Save as Image</button>
  </div>
  <div id="optimization">
    <h2>Optimization</h2>
    <label for="input-text">Text for Optimization:</label>
    <input type="text" id="input-text" placeholder="Enter text to optimize">
    <button id="run-optimization">Run Optimization</button>
    <div id="results"></div>
  </div>
  <input type="file" id="file-input" accept=".json, .png" style="display: none;">

  <script>
    const canvas = document.getElementById('keyboard-canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('file-input');
    const labelInputContainer = document.getElementById('label-input-container');
    const labelInput = document.getElementById('label-input');
    const colorPicker = document.getElementById('color-picker');
    const addLabelButton = document.getElementById('add-label-button');
    const inputText = document.getElementById('input-text');
    const resultsContainer = document.getElementById('results');

    let keyboardTemplate = null; // Image of the uploaded keyboard template
    let markers = []; // Array to store marker positions, labels, colors
    let draggingMarker = null;

    // Initialize canvas dimensions
    const MAX_WIDTH = 800;
    const MAX_HEIGHT = 400;

    // Finger assignment
    const fingerAssignments = {
      leftPinky: ['q', 'a', 'z', 'shift-left'],
      leftRing: ['w', 's', 'x'],
      leftMiddle: ['e', 'd', 'c'],
      leftIndex: ['r', 't', 'f', 'g', 'v', 'b'],
      rightIndex: ['y', 'u', 'h', 'j', 'n', 'm'],
      rightMiddle: ['i', 'k', ','],
      rightRing: ['o', 'l', '.'],
      rightPinky: ['p', ';', '/', 'shift-right'],
      thumbs: ['space']
    };

    // Draw the canvas
    function drawCanvas(highlightKeys = null) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (keyboardTemplate) {
        ctx.drawImage(keyboardTemplate, 0, 0, canvas.width, canvas.height);
      }

      // Draw all markers
      markers.forEach(marker => {
        const { x, y, label, color } = marker;
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = highlightKeys && highlightKeys[label] ? highlightKeys[label] : (color || 'red');
        ctx.fill();
        ctx.stroke();

        if (label) {
          ctx.fillStyle = 'black';
          ctx.font = '12px Arial';
          ctx.fillText(label, x + 10, y - 10);
        }
      });
    }

    // Assign finger to a key based on its label
    function getFingerForKey(keyLabel) {
      for (const [finger, keys] of Object.entries(fingerAssignments)) {
        if (keys.includes(keyLabel.toLowerCase())) {
          return finger;
        }
      }
      return null; // No finger assigned
    }

    // Calculate distance for a layout with multi-finger tracking
    function calculateDistance(layout, text) {
      const fingerPositions = {}; // Tracks the last position of each finger
      let totalDistance = 0;

      for (const char of text) {
        const marker = layout.find(m => m.label === char);
        if (!marker) continue;

        const finger = getFingerForKey(marker.label);
        if (!finger) continue;

        const position = [marker.x, marker.y];

        if (fingerPositions[finger]) {
          const [lastX, lastY] = fingerPositions[finger];
          const dx = position[0] - lastX;
          const dy = position[1] - lastY;
          totalDistance += Math.sqrt(dx * dx + dy * dy);
        }

        fingerPositions[finger] = position; // Update finger position
      }

      return totalDistance;
    }

    // Upload keyboard template
    document.getElementById('upload-template').addEventListener('click', () => {
      fileInput.accept = '.png';
      fileInput.onchange = event => {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = () => {
            const img = new Image();
            img.onload = () => {
              const scaleFactor = Math.min(MAX_WIDTH / img.width, MAX_HEIGHT / img.height, 1);
              keyboardTemplate = img;
              canvas.width = img.width * scaleFactor;
              canvas.height = img.height * scaleFactor;
              drawCanvas();
            };
            img.src = reader.result;
          };
          reader.readAsDataURL(file);
        }
      };
      fileInput.click();
    });

    // Run optimization algorithm
    document.getElementById('run-optimization').addEventListener('click', () => {
      const text = inputText.value.trim();
      if (!text) {
        alert('Please enter text for optimization.');
        return;
      }

      // Generate random layouts and calculate distances
      const layouts = [];
      for (let i = 0; i < 20; i++) {
        const shuffledMarkers = [...markers].sort(() => Math.random() - 0.5);
        layouts.push({ layout: shuffledMarkers, distance: calculateDistance(shuffledMarkers, text) });
      }

      // Sort layouts by distance
      layouts.sort((a, b) => a.distance - b.distance);

      // Display the two best layouts
      resultsContainer.innerHTML = '<h3>Top 2 Optimized Layouts</h3>';
      layouts.slice(0, 2).forEach((result, index) => {
        const div = document.createElement('div');
        div.innerHTML = `
          <h4>Layout ${index + 1}</h4>
          <p>Total Distance: ${result.distance.toFixed(2)}</p>
        `;
        resultsContainer.appendChild(div);
      });
    });

    // Event listeners for dragging and adding markers
    canvas.addEventListener('mousedown', event => {
      const { offsetX: x, offsetY: y } = event;
      draggingMarker = markers.find(marker => Math.hypot(marker.x - x, marker.y - y) < 10);
    });
    canvas.addEventListener('mousemove', event => {
      if (draggingMarker) {
        const { offsetX: x, offsetY: y } = event;
        draggingMarker.x = x;
        draggingMarker.y = y;
        drawCanvas();
      }
    });
    canvas.addEventListener('mouseup', () => (draggingMarker = null));
    canvas.addEventListener('dblclick', event => {
      const { offsetX: x, offsetY: y } = event;
      labelInputContainer.style.display = 'block';
      labelInputContainer.style.left = `${event.pageX}px`;
      labelInputContainer.style.top = `${event.pageY}px`;

      addLabelButton.onclick = () => {
        const label = labelInput.value.trim();
        const color = colorPicker.value;
        if (label) {
          markers.push({ x, y, label, color });
        }
        labelInputContainer.style.display = 'none';
        labelInput.value = '';
        drawCanvas();
      };
    });

    // Initial draw
    drawCanvas();
  </script>
</body>
</html>
